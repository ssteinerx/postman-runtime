<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>runner/extensions/event.command.js - Postman Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home 6.2.6-beta.1</a></h2><h3>Tutorials</h3><ul><li><a href="tutorial-architecture.html">Architecture</a></li><li><a href="tutorial-components.html">Postman Runtime Components</a></li><li><a href="tutorial-new-auth-mechanisms.html">New Authentication Mechanisms</a></li><li><a href="tutorial-request-send-flow.html">Request Send Flow</a></li></ul><h3>Classes</h3><ul><li><a href="Authorizer.html">Authorizer</a><ul class='methods'><li data-type='method'><a href="Authorizer.html#.addHandler">addHandler</a></li><li data-type='method'><a href="Authorizer.html#.removeHandler">removeHandler</a></li><li data-type='method'><a href="Authorizer.html#init">init</a></li><li data-type='method'><a href="Authorizer.html#isInteractive">isInteractive</a></li><li data-type='method'><a href="Authorizer.html#postVerify">postVerify</a></li><li data-type='method'><a href="Authorizer.html#preVerify">preVerify</a></li><li data-type='method'><a href="Authorizer.html#sign">sign</a></li></ul></li><li><a href="Cursor.html">Cursor</a></li><li><a href="global.html#Run">Run</a><ul class='methods'><li data-type='method'><a href="global.html#Run#abort">abort</a></li><li data-type='method'><a href="global.html#Run#pause">pause</a></li><li data-type='method'><a href="global.html#Run#resume">resume</a></li></ul></li><li><a href="Runner.html">Runner</a></li><li><a href="Run-module_Instructions-pool-Instruction.html">Instruction</a><ul class='methods'><li data-type='method'><a href="Run-module_Instructions-pool-Instruction.html#.create">create</a></li><li data-type='method'><a href="Run-module_Instructions-pool-Instruction.html#execute">execute</a></li></ul></li><li><a href="Run-module_Timer-Timings.html">Timings</a><ul class='methods'><li data-type='method'><a href="Run-module_Timer-Timings.html#.create">create</a></li><li data-type='method'><a href="Run-module_Timer-Timings.html#record">record</a></li><li data-type='method'><a href="Run-module_Timer-Timings.html#toObject">toObject</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="Run-module_Instructions.html">Instructions</a><ul class='methods'><li data-type='method'><a href="Run-module_Instructions.html#~pool">pool</a></li></ul></li><li><a href="Run-module_Timer.html">Timer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#bof">bof</a></li><li><a href="global.html#bounds">bounds</a></li><li><a href="global.html#box">box</a></li><li><a href="global.html#clear">clear</a></li><li><a href="global.html#commands">commands</a></li><li><a href="global.html#connect">connect</a></li><li><a href="global.html#cr">cr</a></li><li><a href="global.html#create">create</a></li><li><a href="global.html#createContext">createContext</a></li><li><a href="global.html#current">current</a></li><li><a href="global.html#empty">empty</a></li><li><a href="global.html#eof">eof</a></li><li><a href="global.html#FUNCTION">FUNCTION</a></li><li><a href="global.html#hasChanged">hasChanged</a></li><li><a href="global.html#initialisers">initialisers</a></li><li><a href="global.html#interrupt">interrupt</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#lookup">lookup</a></li><li><a href="global.html#meetExpectations">meetExpectations</a></li><li><a href="global.html#next">next</a></li><li><a href="global.html#prepareLookupHash">prepareLookupHash</a></li><li><a href="global.html#queue">queue</a></li><li><a href="global.html#REQUEST_MODES">REQUEST_MODES</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#run">run</a></li><li><a href="global.html#seek">seek</a></li><li><a href="global.html#setCertificate">setCertificate</a></li><li><a href="global.html#setProxy">setProxy</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#toChromeCookie">toChromeCookie</a></li><li><a href="global.html#transformMultiValueHeaders">transformMultiValueHeaders</a></li><li><a href="global.html#triggers">triggers</a></li><li><a href="global.html#valueOf">valueOf</a></li><li><a href="global.html#whatnext">whatnext</a></li><li><a href="global.html#zero">zero</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">runner/extensions/event.command.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var _ = require('lodash'),
    uuid = require('uuid'),
    async = require('async'),

    util = require('../util'),
    sdk = require('postman-collection'),
    sandbox = require('postman-sandbox'),
    serialisedError = require('serialised-error'),

    ASSERTION_FAILURE = 'AssertionFailure',
    SAFE_CONTEXT_VARIABLES = ['environment', 'globals', 'cookies', 'data', 'request', 'response'],

    postProcessContext = function (execution, failures) { // function determines whether the event needs to abort
        var tests = execution &amp;&amp; execution.tests,
            error;

        _.forOwn(tests, function (result, test) {
            !result &amp;&amp; (failures || (failures = [])).push(test);
        });

        if (failures &amp;&amp; failures.length) {
            error = new Error(failures.join(', '));
            error.name = ASSERTION_FAILURE;
        }
        return error ? serialisedError(error, true) : undefined;
    };

/**
 * Script execution extenion of the runner.
 * This module exposes processors for executing scripts before and after requests. Essentially, the processors are
 * itself not aware of other processors and simply allow running of a script and then queue a procesor as defined in
 * payload.
 *
 * Adds options
 * - suppressEventPropagation:Boolean [true]
 * - stopOnScriptError:Boolean [false]
 * - host:Object [undefined]
 */
module.exports = {
    init: function (done) {
        var run = this;

        // if this run object already has a host, we do not need to create one.
        if (run.host) {
            return done();
        }

        // @todo - remove this when chrome app and electron host creation is offloaded to runner
        // @todo - can this be removed now in runtime v4?
        if (run.options.host &amp;&amp; run.options.host.external === true) {
            run.host = run.options.host.instance;
            return done();
        }

        sandbox.createContext(_.merge({
            // debug: true
        }, run.options.host), function (err, context) {
            if (err) { return done(err); }
            // store the host in run object for future use and move on
            run.host = context;

            context.on('console', function () {
                run.triggers.console.apply(run.triggers, arguments);
            });

            context.on('error', function () {
                run.triggers.error.apply(run.triggers, arguments);
            });

            context.on('execution.error', function () {
                run.triggers.exception.apply(run.triggers, arguments);
            });

            context.on('execution.assertion', function () {
                run.triggers.assertion.apply(run.triggers, arguments);
            });

            context.on('execution.request', function (cursor, id, requestId, request) {
                run.requester.create({
                    type: 'http',
                    source: 'script', // @todo - get script type from the sandbox
                    cursor: cursor
                }, function (err, requester) { // eslint-disable-line handle-callback-err
                    var sendId = id + '.' + requestId;

                    requester.on(sendId, run.triggers.io.bind(run.triggers));

                    return requester.request(sendId, new sdk.Request(request), function (err, res) {
                        context.dispatch('execution.response.' + id, requestId, err, res);
                        requester.dispose();
                    });
                });
            });

            done();
        });
    },

    /**
     * This lists the name of the events that the script processors are likely to trigger
     *
     * @type {Array}
     */
    triggers: ['beforeScript', 'script', 'assertion', 'exception', 'console'],

    process: {
        /**
         * This processors job is to do the following:
         * - trigger event by its name
         * - execute all scripts that the event listens to and return execution results
         *
         * @param {Object} payload
         * @param {String} payload.name
         * @param {Item} payload.item
         * @param {Object} [payload.context]
         * @param {Cursor} [payload.coords]
         * @param {Array.&lt;String>} [payload.trackContext]
         * @param {Boolean} [payload.stopOnScriptError] - if set to true, then a synchronous error encountered during
         * execution of a script will stop executing any further scripts
         * @param {Boolean} [payload.abortOnFailure]
         * @param {Boolean} [payload.stopOnFailure]
         * @param {Function} next
         *
         * @note - in order to raise trigger for the entire event, ensure your extension has registered the triggers
         */
        event: function (payload, next) {
            var suppressEventPropagation = _.has(this.options, 'suppressEventPropagation') ?
                    this.options.suppressEventPropagation : true,
                item = payload.item,
                eventName = payload.name,
                cursor = payload.coords,
                // the payload can have a list of variables to track from the context post execution, ensure that
                // those are accurately set
                track = _.isArray(payload.trackContext) &amp;&amp; _.isObject(payload.context) &amp;&amp;
                    // ensure that only those variables that are defined in the context are synced
                    payload.trackContext.filter(function (variable) {
                        return _.isObject(payload.context[variable]);
                    }),
                stopOnScriptError = (_.has(payload, 'stopOnScriptError') ? payload.stopOnScriptError :
                    this.options.stopOnScriptError),
                abortOnError = (_.has(payload, 'abortOnError') ? payload.abortOnError : this.options.abortOnError),

                // @todo: find a better home for this option processing
                abortOnFailure = payload.abortOnFailure,
                stopOnFailure = payload.stopOnFailure,

                events;

            // @todo: find a better place to code this so that event is not aware of such options
            if (abortOnFailure) {
                abortOnError = true;
            }

            // validate the payload
            if (!eventName) {
                return next(new Error('runner.extension~events: event payload is missing the event name.'));
            }
            if (!item) {
                return next(new Error('runner.extension~events: event payload is missing the triggered item.'));
            }

            // get the list of events to be executed. note that based on the `suppressEventPropagation` option, use
            // all inherited events or own events only
            events = suppressEventPropagation ? item.events.listenersOwn(eventName) : item.events.listeners(eventName);

            // call the "before" event trigger by its event name.
            // at this point, the one who queued this event, must ensure that the trigger for it is defined in its
            // 'trigger' interface
            this.triggers[_.camelCase('before-' + eventName)](null, cursor, events, item);

            // with all the event listeners in place, we now iterate on them and execute its scripts. post execution,
            // we accumulate the results in order to be passed on to the event callback trigger.
            async.mapSeries(events, function (event, next) {
                // in case the event has no script we bail out early
                if (!event.script) {
                    return next(null, {event: event});
                }

                // get access to the script from the event.
                var script = event.script,
                    executionId = uuid(),
                    assertionFailed = [];

                // store the execution id in script
                script._lastExecutionId = executionId; // please don't use it anywhere else!

                // trigger the "beforeScript" callback
                this.triggers.beforeScript(null, cursor, script, event, item);

                // add event listener to trap all assertion events, but only if needed. to avoid needlessly accumulate
                // stuff in memory.
                (abortOnFailure || stopOnFailure) &amp;&amp;
                    this.host.on('execution.assertion.' + executionId, function (cursor, assertion) {
                        !assertion.passed &amp;&amp; assertionFailed.push(assertion.name);
                    });

                // finally execute the script
                this.host.execute(event, {
                    id: executionId,
                    // debug: true,
                    timeout: payload.scriptTimeout,
                    cursor: cursor,
                    context: _.pick(payload.context, SAFE_CONTEXT_VARIABLES),

                    // legacy options
                    legacy: {
                        _itemId: item.id,
                        _itemName: item.name
                    }
                }, function (err, result) {
                    this.host.removeAllListeners('execution.assertion.' + executionId);
                    this.host.removeAllListeners('execution.error.' + executionId);

                    // electron IPC does not bubble errors to the browser process, so we serialize it here.
                    err &amp;&amp; (err = serialisedError(err, true));

                    // if it is defined that certain variables are to be synced back to result, we do the same
                    track &amp;&amp; result &amp;&amp; track.forEach(function (variable) {
                        if (!(_.isObject(result[variable]) &amp;&amp; payload.context[variable])) { return; }

                        // ensure that variablescope is treated accordingly
                        // @todo find a better way to not sync entire scope, but receive changes and update the existing
                        // scope using that
                        if (_.isFunction(payload.context[variable].syncVariablesFrom)) {
                            payload.context[variable].clear();
                            _.forEach(result[variable].values, function (def) {
                                payload.context[variable].values.add(def);
                            });
                        }
                        else {
                            util.syncObject(payload.context[variable], result[variable]);
                        }
                    });

                    // Get the failures. If there was an error running the script itself, that takes precedence
                    if (!err &amp;&amp; (abortOnFailure || stopOnFailure)) {
                        err = postProcessContext(result, assertionFailed); // also use async assertions
                    }

                    // Ensure that we have SDK instances, not serialized plain objects.
                    // @todo - should this be handled by the sandbox?
                    result &amp;&amp; result.environment &amp;&amp; (result.environment = new sdk.VariableScope(result.environment));
                    result &amp;&amp; result.globals &amp;&amp; (result.globals = new sdk.VariableScope(result.globals));
                    result &amp;&amp; result.request &amp;&amp; (result.request = new sdk.Request(result.request));
                    result &amp;&amp; result.response &amp;&amp; (result.response = new sdk.Response(result.response));

                    // now that this script is done executing, we trigger the event and move to the next script
                    this.triggers.script(err || null, cursor, result, script, event, item);

                    // move to next script and pass on the results for accumulation
                    next(((stopOnScriptError || abortOnError || stopOnFailure) &amp;&amp; err) ? err : null, _.assign({
                        event: event,
                        script: script,
                        result: result
                    }, err &amp;&amp; {error: err})); // we use assign here to avoid needless error property
                }.bind(this));

            }.bind(this), function (err, results) {
                // trigger the event completion callback
                this.triggers[eventName](null, cursor, results, item);
                next((abortOnError &amp;&amp; err) ? err : null, results, err);
            }.bind(this));
        }
    }
};
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated at Mon Jul 24 2017 12:14:31 GMT+0000 (UTC)
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
